{"version":3,"file":"react-three-editable.cjs.production.min.js","sources":["../src/store.ts","../src/components/editable.tsx"],"sourcesContent":["import create, { StateCreator } from 'zustand';\nimport {\n  DefaultLoadingManager,\n  Matrix4,\n  Object3D,\n  Scene,\n  WebGLRenderer,\n} from 'three';\nimport { MutableRefObject } from 'react';\nimport { OrbitControls } from '@react-three/drei';\nimport deepEqual from 'fast-deep-equal';\n\nexport type EditableType =\n  | 'group'\n  | 'mesh'\n  | 'spotLight'\n  | 'directionalLight'\n  | 'pointLight'\n  | 'perspectiveCamera'\n  | 'orthographicCamera';\nexport type TransformControlsMode = 'translate' | 'rotate' | 'scale';\nexport type TransformControlsSpace = 'world' | 'local';\nexport type ViewportShading = 'wireframe' | 'flat' | 'solid' | 'rendered';\n\nexport interface AbstractEditable<T extends EditableType> {\n  type: T;\n  role: 'active' | 'removed';\n  properties: {};\n  initialProperties: this['properties'];\n}\n\n// all these identical types are to prepare for a future in which different object types have different properties\nexport interface EditableGroup extends AbstractEditable<'group'> {\n  properties: {\n    transform: Matrix4;\n  };\n}\n\nexport interface EditableMesh extends AbstractEditable<'mesh'> {\n  properties: {\n    transform: Matrix4;\n  };\n}\n\nexport interface EditableSpotLight extends AbstractEditable<'spotLight'> {\n  properties: {\n    transform: Matrix4;\n  };\n}\n\nexport interface EditableDirectionalLight\n  extends AbstractEditable<'directionalLight'> {\n  properties: {\n    transform: Matrix4;\n  };\n}\n\nexport interface EditablePointLight extends AbstractEditable<'pointLight'> {\n  properties: {\n    transform: Matrix4;\n  };\n}\n\nexport interface EditablePerspectiveCamera\n  extends AbstractEditable<'perspectiveCamera'> {\n  properties: {\n    transform: Matrix4;\n  };\n}\n\nexport interface EditableOrthographicCamera\n  extends AbstractEditable<'orthographicCamera'> {\n  properties: {\n    transform: Matrix4;\n  };\n}\n\nexport type Editable =\n  | EditableGroup\n  | EditableMesh\n  | EditableSpotLight\n  | EditableDirectionalLight\n  | EditablePointLight\n  | EditablePerspectiveCamera\n  | EditableOrthographicCamera;\n\nexport type EditableSnapshot<T extends Editable = Editable> = {\n  proxyObject?: Object3D | null;\n} & T;\n\nexport interface AbstractSerializedEditable<T extends EditableType> {\n  type: T;\n}\n\nexport interface SerializedEditableGroup\n  extends AbstractSerializedEditable<'group'> {\n  properties: {\n    transform: number[];\n  };\n}\n\nexport interface SerializedEditableMesh\n  extends AbstractSerializedEditable<'mesh'> {\n  properties: {\n    transform: number[];\n  };\n}\n\nexport interface SerializedEditableSpotLight\n  extends AbstractSerializedEditable<'spotLight'> {\n  properties: {\n    transform: number[];\n  };\n}\n\nexport interface SerializedEditableDirectionalLight\n  extends AbstractSerializedEditable<'directionalLight'> {\n  properties: {\n    transform: number[];\n  };\n}\n\nexport interface SerializedEditablePointLight\n  extends AbstractSerializedEditable<'pointLight'> {\n  properties: {\n    transform: number[];\n  };\n}\n\nexport interface SerializedEditablePerspectiveCamera\n  extends AbstractSerializedEditable<'perspectiveCamera'> {\n  properties: {\n    transform: number[];\n  };\n}\n\nexport interface SerializedEditableOrthographicCamera\n  extends AbstractSerializedEditable<'orthographicCamera'> {\n  properties: {\n    transform: number[];\n  };\n}\n\nexport type SerializedEditable =\n  | SerializedEditableGroup\n  | SerializedEditableMesh\n  | SerializedEditableSpotLight\n  | SerializedEditableDirectionalLight\n  | SerializedEditablePointLight\n  | SerializedEditablePerspectiveCamera\n  | SerializedEditableOrthographicCamera;\n\nexport interface EditableState {\n  editables: Record<string, SerializedEditable>;\n}\n\nexport type EditorStore = {\n  scene: Scene | null;\n  gl: WebGLRenderer | null;\n  allowImplicitInstancing: boolean;\n  orbitControlsRef: MutableRefObject<OrbitControls | undefined> | null;\n  editables: Record<string, Editable>;\n  // this will come in handy when we start supporting multiple canvases\n  canvasName: string;\n  initialState: EditableState | null;\n  selected: string | null;\n  transformControlsMode: TransformControlsMode;\n  transformControlsSpace: TransformControlsSpace;\n  viewportShading: ViewportShading;\n  editorOpen: boolean;\n  sceneSnapshot: Scene | null;\n  editablesSnapshot: Record<string, EditableSnapshot> | null;\n  hdrPaths: string[];\n  selectedHdr: string | null;\n  showOverlayIcons: boolean;\n  useHdrAsBackground: boolean;\n  showGrid: boolean;\n  showAxes: boolean;\n\n  init: (\n    scene: Scene,\n    gl: WebGLRenderer,\n    allowImplicitInstancing: boolean,\n    initialState?: EditableState\n  ) => void;\n  setOrbitControlsRef: (\n    orbitControlsRef: MutableRefObject<OrbitControls | undefined>\n  ) => void;\n  addEditable: <T extends EditableType>(\n    type: T,\n    uniqueName: string,\n    initialProperties: Extract<Editable, { type: T }>['properties']\n  ) => void;\n  removeEditable: (uniqueName: string) => void;\n  setEditableTransform: (uniqueName: string, transform: Matrix4) => void;\n  setSelected: (name: string | null) => void;\n  setSelectedHdr: (hdr: string | null) => void;\n  setTransformControlsMode: (mode: TransformControlsMode) => void;\n  setTransformControlsSpace: (mode: TransformControlsSpace) => void;\n  setViewportShading: (mode: ViewportShading) => void;\n  setShowOverlayIcons: (show: boolean) => void;\n  setUseHdrAsBackground: (use: boolean) => void;\n  setShowGrid: (show: boolean) => void;\n  setShowAxes: (show: boolean) => void;\n  setEditorOpen: (open: boolean) => void;\n  createSnapshot: () => void;\n  setSnapshotProxyObject: (\n    proxyObject: Object3D | null,\n    uniqueName: string\n  ) => void;\n  serialize: () => EditableState;\n  isPersistedStateDifferentThanInitial: () => boolean;\n  applyPersistedState: () => void;\n};\n\ninterface PersistedState {\n  canvases: {\n    [name: string]: EditableState;\n  };\n}\n\nconst config: StateCreator<EditorStore> = (set, get) => {\n  setTimeout(() => {\n    const existingHandler = DefaultLoadingManager.onProgress;\n    DefaultLoadingManager.onProgress = (url, loaded, total) => {\n      existingHandler(url, loaded, total);\n      if (url.match(/\\.hdr$/)) {\n        set((state) => {\n          const newPaths = new Set(state.hdrPaths);\n          newPaths.add(url);\n          return { hdrPaths: Array.from(newPaths) };\n        });\n      }\n    };\n  });\n\n  return {\n    scene: null,\n    gl: null,\n    allowImplicitInstancing: false,\n    orbitControlsRef: null,\n    editables: {},\n    canvasName: 'default',\n    initialState: null,\n    selected: null,\n    transformControlsMode: 'translate',\n    transformControlsSpace: 'world',\n    viewportShading: 'rendered',\n    editorOpen: false,\n    sceneSnapshot: null,\n    editablesSnapshot: null,\n    hdrPaths: [],\n    selectedHdr: null,\n    showOverlayIcons: false,\n    useHdrAsBackground: true,\n    showGrid: true,\n    showAxes: true,\n\n    init: (scene, gl, allowImplicitInstancing, initialState) => {\n      const editables = get().editables;\n\n      const newEditables: Record<string, Editable> = initialState\n        ? Object.fromEntries(\n            Object.entries(initialState.editables).map(([name, editable]) => {\n              const originalEditable = editables[name];\n              return [\n                name,\n                {\n                  type: editable.type,\n                  role: originalEditable?.role ?? 'removed',\n                  properties: {\n                    transform: new Matrix4().fromArray(\n                      editable.properties.transform\n                    ),\n                  },\n                  initialProperties: originalEditable?.initialProperties ?? {\n                    transform: new Matrix4(),\n                  },\n                },\n              ];\n            })\n          )\n        : editables;\n\n      set({\n        scene,\n        gl,\n        allowImplicitInstancing,\n        editables: newEditables,\n        initialState,\n      });\n    },\n    addEditable: (type, uniqueName, initialProperties) =>\n      set((state) => {\n        let properties = initialProperties;\n        if (state.editables[uniqueName]) {\n          if (\n            state.editables[uniqueName].type !== type &&\n            process.env.NODE_ENV === 'development'\n          ) {\n            console.error(`Warning: There is a mismatch between the serialized type of ${uniqueName} and the one set when adding it to the scene.\n  Serialized: ${state.editables[uniqueName].type}.\n  Current: ${type}.\n  \n  This might have happened either because you changed the type of an object, in which case a re-export will solve the issue, or because you re-used the uniqueName for an object of a different type, which is an error.`);\n          }\n          if (\n            state.editables[uniqueName].role === 'active' &&\n            !state.allowImplicitInstancing\n          ) {\n            throw Error(\n              `Scene already has an editable object named ${uniqueName}.\n  If this is intentional, please set the allowImplicitInstancing prop of EditableManager to true.`\n            );\n          } else {\n            properties = state.editables[uniqueName].properties;\n          }\n        }\n\n        return {\n          editables: {\n            ...state.editables,\n            [uniqueName]: {\n              type: type as EditableType,\n              role: 'active',\n              properties,\n              initialProperties,\n            },\n          },\n        };\n      }),\n    setOrbitControlsRef: (camera) => {\n      set({ orbitControlsRef: camera });\n    },\n    removeEditable: (name) =>\n      set((state) => {\n        const { [name]: removed, ...rest } = state.editables;\n        return {\n          editables: {\n            ...rest,\n            [name]: { ...removed, role: 'removed' },\n          },\n        };\n      }),\n    setEditableTransform: (uniqueName, transform) => {\n      set((state) => ({\n        editables: {\n          ...state.editables,\n          [uniqueName]: {\n            ...state.editables[uniqueName],\n            properties: { transform },\n          },\n        },\n      }));\n    },\n    setSelected: (name) => {\n      set({ selected: name });\n    },\n    setSelectedHdr: (hdr) => {\n      set({ selectedHdr: hdr });\n    },\n    setTransformControlsMode: (mode) => {\n      set({ transformControlsMode: mode });\n    },\n    setTransformControlsSpace: (mode) => {\n      set({ transformControlsSpace: mode });\n    },\n    setViewportShading: (mode) => {\n      set({ viewportShading: mode });\n    },\n    setShowOverlayIcons: (show) => {\n      set({ showOverlayIcons: show });\n    },\n    setUseHdrAsBackground: (use) => {\n      set({ useHdrAsBackground: use });\n    },\n    setShowGrid: (show) => {\n      set({ showGrid: show });\n    },\n    setShowAxes: (show) => {\n      set({ showAxes: show });\n    },\n    setEditorOpen: (open) => {\n      set({ editorOpen: open });\n    },\n    createSnapshot: () => {\n      set((state) => ({\n        sceneSnapshot: state.scene?.clone(),\n        editablesSnapshot: state.editables,\n      }));\n    },\n    setSnapshotProxyObject: (proxyObject, uniqueName) => {\n      set((state) => ({\n        editablesSnapshot: {\n          ...state.editablesSnapshot,\n          [uniqueName]: {\n            ...state.editablesSnapshot![uniqueName],\n            proxyObject,\n          },\n        },\n      }));\n    },\n    serialize: () => ({\n      editables: Object.fromEntries(\n        Object.entries(get().editables).map(([name, editable]) => [\n          name,\n          {\n            type: editable.type,\n            properties: {\n              transform: editable.properties.transform.toArray(),\n            },\n          },\n        ])\n      ),\n    }),\n    isPersistedStateDifferentThanInitial: () => {\n      const initialState = get().initialState;\n      const canvasName = get().canvasName!;\n\n      if (!initialState || !initialPersistedState) {\n        return false;\n      }\n\n      return !deepEqual(\n        initialPersistedState.canvases[canvasName],\n        initialState\n      );\n    },\n    applyPersistedState: () => {\n      const editables = get().editables;\n      const canvasName = get().canvasName!;\n\n      if (!initialPersistedState) {\n        return;\n      }\n\n      const newEditables: Record<string, Editable> = Object.fromEntries(\n        Object.entries(\n          initialPersistedState.canvases[canvasName].editables\n        ).map(([name, editable]) => {\n          const originalEditable = editables[name];\n          return [\n            name,\n            {\n              type: editable.type,\n              role: originalEditable?.role ?? 'removed',\n              properties: {\n                transform: new Matrix4().fromArray(\n                  editable.properties.transform\n                ),\n              },\n              initialProperties: originalEditable?.initialProperties ?? {\n                transform: new Matrix4(),\n              },\n            },\n          ];\n        })\n      );\n\n      set({\n        editables: newEditables,\n      });\n    },\n  };\n};\n\nexport const useEditorStore = create<EditorStore>(config);\n\nconst initPersistence = (\n  key: string\n): [PersistedState | null, (() => void) | undefined] => {\n  let initialPersistedState: PersistedState | null = null;\n  let unsub;\n\n  if (process.env.NODE_ENV === 'development') {\n    try {\n      const rawPersistedState = localStorage.getItem(key);\n      if (rawPersistedState) {\n        initialPersistedState = JSON.parse(rawPersistedState);\n      }\n    } catch (e) {}\n\n    unsub = useEditorStore.subscribe(\n      () => {\n        const canvasName = useEditorStore.getState().canvasName;\n        const serialize = useEditorStore.getState().serialize;\n        if (canvasName) {\n          const editables = serialize();\n          localStorage.setItem(\n            key,\n            JSON.stringify({\n              canvases: {\n                [canvasName]: editables,\n              },\n            })\n          );\n        }\n      },\n      (state) => state.editables\n    );\n  }\n\n  return [initialPersistedState, unsub];\n};\n\nlet [initialPersistedState, unsub] = initPersistence('react-three-editable_');\n\nexport type BindFunction = (options?: {\n  allowImplicitInstancing?: boolean;\n  state?: EditableState;\n}) => (options: { gl: WebGLRenderer; scene: Scene }) => void;\n\nexport const configure = ({\n  localStorageNamespace = '',\n  enablePersistence = true,\n} = {}): BindFunction => {\n  if (unsub) {\n    unsub();\n  }\n\n  if (enablePersistence) {\n    const persistence = initPersistence(\n      `react-three-editable_${localStorageNamespace}`\n    );\n\n    initialPersistedState = persistence[0];\n    unsub = persistence[1];\n  } else {\n    initialPersistedState = null;\n    unsub = undefined;\n  }\n\n  return ({ allowImplicitInstancing = false, state } = {}) => {\n    return ({ gl, scene }) => {\n      const init = useEditorStore.getState().init;\n      init(scene, gl, allowImplicitInstancing, state);\n    };\n  };\n};\n","import React, {\n  ComponentProps,\n  forwardRef,\n  JSXElementConstructor,\n  RefAttributes,\n  useLayoutEffect,\n  useRef,\n} from 'react';\nimport {\n  DirectionalLight,\n  Euler,\n  Group,\n  Matrix4,\n  Mesh,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Quaternion,\n  SpotLight,\n  Vector3,\n} from 'three';\nimport { EditableType, useEditorStore } from '../store';\nimport shallow from 'zustand/shallow';\nimport mergeRefs from 'react-merge-refs';\n\ninterface Elements {\n  group: Group;\n  mesh: Mesh;\n  spotLight: SpotLight;\n  directionalLight: DirectionalLight;\n  perspectiveCamera: PerspectiveCamera;\n  orthographicCamera: OrthographicCamera;\n  pointLight: PointLight;\n}\n\nconst editable = <\n  T extends JSXElementConstructor<any> | EditableType,\n  U extends EditableType\n>(\n  Component: T,\n  type: U\n) =>\n  forwardRef(\n    (\n      {\n        uniqueName,\n        position,\n        rotation,\n        scale,\n        ...props\n      }: ComponentProps<T> & {\n        uniqueName: string;\n      } & RefAttributes<Elements[U]>,\n      ref\n    ) => {\n      const objectRef = useRef<Elements[U]>();\n\n      const [addEditable, removeEditable] = useEditorStore(\n        (state) => [state.addEditable, state.removeEditable],\n        shallow\n      );\n\n      const transformDeps: string[] = [];\n\n      ['x', 'y', 'z'].forEach((axis) => {\n        transformDeps.push(\n          props[`position-${axis}`],\n          props[`rotation-${axis}`],\n          props[`scale-${axis}`]\n        );\n      });\n\n      useLayoutEffect(() => {\n        // calculate initial properties before adding the editable\n        const pos: Vector3 = position\n          ? new Vector3(...position)\n          : new Vector3();\n        const rot: Vector3 = rotation\n          ? new Vector3(...rotation)\n          : new Vector3();\n        const scal: Vector3 = scale\n          ? new Vector3(...scale)\n          : new Vector3(1, 1, 1);\n\n        ['x', 'y', 'z'].forEach((axis, index) => {\n          if (props[`position-${axis}`])\n            pos.setComponent(index, props[`position-${axis}`]);\n          if (props[`rotation-${axis}`])\n            rot.setComponent(index, props[`rotation-${axis}`]);\n          if (props[`scale-${axis}`])\n            scal.setComponent(index, props[`scale-${axis}`]);\n        });\n\n        const quaternion = new Quaternion().setFromEuler(\n          new Euler().setFromVector3(rot)\n        );\n\n        addEditable(type, uniqueName, {\n          transform: new Matrix4().compose(pos, quaternion, scal),\n        });\n\n        return () => {\n          removeEditable(uniqueName);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [\n        addEditable,\n        position,\n        removeEditable,\n        rotation,\n        scale,\n        uniqueName,\n\n        // nasty\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        ...transformDeps,\n      ]);\n\n      useLayoutEffect(() => {\n        const object = objectRef.current!;\n        // source of truth is .position, .quaternion and .scale, not the matrix, so we have to do this instead of setting the matrix\n        useEditorStore\n          .getState()\n          .editables[uniqueName].properties.transform.decompose(\n            object.position,\n            object.quaternion,\n            object.scale\n          );\n\n        const unsub = useEditorStore.subscribe(\n          (transform: Matrix4 | null) => {\n            if (transform) {\n              useEditorStore\n                .getState()\n                .editables[uniqueName].properties.transform.decompose(\n                  object.position,\n                  object.quaternion,\n                  object.scale\n                );\n            }\n          },\n          (state) => state.editables[uniqueName].properties.transform\n        );\n\n        return () => {\n          unsub();\n        };\n      }, [uniqueName]);\n\n      return (\n        // @ts-ignore\n        <Component\n          ref={mergeRefs([objectRef, ref])}\n          {...props}\n          userData={{\n            __editable: true,\n            __editableName: uniqueName,\n            __editableType: type,\n          }}\n        />\n      );\n    }\n  );\n\nconst createEditable = <T extends EditableType>(type: T) =>\n  editable(type, type);\n\neditable.group = createEditable('group');\neditable.mesh = createEditable('mesh');\neditable.spotLight = createEditable('spotLight');\neditable.directionalLight = createEditable('directionalLight');\neditable.pointLight = createEditable('pointLight');\neditable.perspectiveCamera = createEditable('perspectiveCamera');\neditable.orthographicCamera = createEditable('orthographicCamera');\n\nexport default editable;\n"],"names":["useEditorStore","create","set","get","setTimeout","existingHandler","DefaultLoadingManager","onProgress","url","loaded","total","match","state","newPaths","Set","hdrPaths","add","Array","from","scene","gl","allowImplicitInstancing","orbitControlsRef","editables","canvasName","initialState","selected","transformControlsMode","transformControlsSpace","viewportShading","editorOpen","sceneSnapshot","editablesSnapshot","selectedHdr","showOverlayIcons","useHdrAsBackground","showGrid","showAxes","init","newEditables","Object","fromEntries","entries","map","name","editable","originalEditable","type","role","properties","transform","Matrix4","fromArray","initialProperties","addEditable","uniqueName","Error","setOrbitControlsRef","camera","removeEditable","removed","setEditableTransform","setSelected","setSelectedHdr","hdr","setTransformControlsMode","mode","setTransformControlsSpace","setViewportShading","setShowOverlayIcons","show","setUseHdrAsBackground","use","setShowGrid","setShowAxes","setEditorOpen","open","createSnapshot","_state$scene","clone","setSnapshotProxyObject","proxyObject","serialize","toArray","isPersistedStateDifferentThanInitial","initialPersistedState","deepEqual","canvases","applyPersistedState","key","unsub","initPersistence","Component","forwardRef","ref","position","rotation","scale","props","objectRef","useRef","shallow","transformDeps","forEach","axis","push","useLayoutEffect","pos","Vector3","rot","scal","index","setComponent","quaternion","Quaternion","setFromEuler","Euler","setFromVector3","compose","object","current","getState","decompose","subscribe","React","mergeRefs","userData","__editable","__editableName","__editableType","createEditable","group","mesh","spotLight","directionalLight","pointLight","perspectiveCamera","orthographicCamera","enablePersistence","persistence","undefined"],"mappings":"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"}